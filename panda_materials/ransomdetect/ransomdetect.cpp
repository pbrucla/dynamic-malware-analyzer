#include <chrono>
#include <cstdint>
#include <iostream>
#include <limits.h>
#include <stdio.h>
#include <string>
#include <unordered_map>

// PANDA framework headers
#include "panda/plugin.h"
#include "panda/plugin_plugin.h"

extern "C" {
#include "ransomdetect_api.h"
#include "ransomdetect_int.h"
#include "ransomdetect_int_fns.h"
}

using namespace std;

void* self_ptr;
panda_cb pcb_virt_memwrite;
panda_cb pcb_phys_memwrite;
panda_cb pcb_hd_write;
panda_cb pcb_insn_exec;

// Track file operations counts per process
unordered_map<uint32_t, uint64_t> file_operations_count;

// Threshold for considering abnormal activity (e.g., 100 operations)
const uint64_t OPERATION_THRESHOLD = 100;

extern "C" {
bool init_plugin(void *);
void uninit_plugin(void *);

PPP_PROT_REG_CB(PANDA_CB_VIRT_MEM_BEFORE_WRITE);
PPP_PROT_REG_CB(PANDA_CB_PHYS_MEM_BEFORE_WRITE);
PPP_PROT_REG_CB(PANDA_CB_HD_WRITE);
PPP_PROT_REG_CB(PANDA_CB_INSN_EXEC);
}

PPP_CB_BOILERPLATE(PANDA_CB_VIRT_MEM_BEFORE_WRITE);
PPP_CB_BOILERPLATE(PANDA_CB_PHYS_MEM_BEFORE_WRITE);
PPP_CB_BOILERPLATE(PANDA_CB_HD_WRITE);
PPP_CB_BOILERPLATE(PANDA_CB_INSN_EXEC);

void on_virt_mem_write(CPUState *cpu, uint32_t pc, uint32_t addr, uint32_t size) {
    // Retrieve current process ID (PID)
    uint32_t pid = panda_current_asid(cpu);

    // Increment operation count for this PID
    file_operations_count[pid]++;

    // Check if the operation count exceeds our threshold
    if (file_operations_count[pid] > OPERATION_THRESHOLD) {
        cout << "Potential ransomware activity detected: High volume of write operations by PID " << pid << endl;
        log_suspicious_activity(pid, "Virtual Memory Write");
    }
}

void on_phys_mem_write(CPUState *cpu, uint32_t pc, uint32_t addr, uint32_t size) {
    // Retrieve current process ID (PID)
    uint32_t pid = panda_current_asid(cpu);

    // Increment operation count for this PID
    file_operations_count[pid]++;

    // Check if the operation count exceeds our threshold
    if (file_operations_count[pid] > OPERATION_THRESHOLD) {
        cout << "Potential ransomware activity detected: High volume of write operations by PID " << pid << endl;
        log_suspicious_activity(pid, "Physical Memory Write");
    }
}

void on_hd_write(CPUState *cpu, uint64_t offset, uint32_t size, uint32_t flags) {
    // Retrieve current process ID (PID)
    uint32_t pid = panda_current_asid(cpu);

    // Increment operation count for this PID
    file_operations_count[pid]++;

    // Check if the operation count exceeds our threshold
    if (file_operations_count[pid] > OPERATION_THRESHOLD) {
        cout << "Potential ransomware activity detected: High volume of write operations by PID " << pid << endl;
        log_suspicious_activity(pid, "Hard Disk Write");
    }
}

void on_insn_exec(CPUState *cpu, uint32_t pc) {
    // Retrieve current process ID (PID)
    uint32_t pid = panda_current_asid(cpu);

    // Increment operation count for this PID
    file_operations_count[pid]++;

    // Check if the operation count exceeds our threshold
    if (file_operations_count[pid] > OPERATION_THRESHOLD) {
        cout << "Potential ransomware activity detected: High volume of write operations by PID " << pid << endl;
        log_suspicious_activity(pid, "Instruction Execution");
    }
}

void log_suspicious_activity(uint32_t pid, const char *activity_type) {
    // Log the suspicious activity to a file or send an alert
    ofstream log_file("suspicious_activity.log", ios::app);
    if (log_file.is_open()) {
        log_file << "PID: " << pid << ", Activity: " << activity_type << endl;
        log_file.close();
    }
}

bool init_plugin(void *self) {
    self_ptr = self;

    // Register the PANDA_CB_VIRT_MEM_BEFORE_WRITE callback
    pcb_virt_memwrite.virt_mem_before_write = on_virt_mem_write;
    panda_register_callback(self, PANDA_CB_VIRT_MEM_BEFORE_WRITE, pcb_virt_memwrite);
    panda_disable_callback(self, PANDA_CB_VIRT_MEM_BEFORE_WRITE, pcb_virt_memwrite);

    // Register the PANDA_CB_PHYS_MEM_BEFORE_WRITE callback
    pcb_phys_memwrite.phys_mem_before_write = on_phys_mem_write;
    panda_register_callback(self, PANDA_CB_PHYS_MEM_BEFORE_WRITE, pcb_phys_memwrite);
    panda_disable_callback(self, PANDA_CB_PHYS_MEM_BEFORE_WRITE, pcb_phys_memwrite);

    // Register the PANDA_CB_HD_WRITE callback
    pcb_hd_write.hd_write = on_hd_write;
    panda_register_callback(self, PANDA_CB_HD_WRITE, pcb_hd_write);
    panda_disable_callback(self, PANDA_CB_HD_WRITE, pcb_hd_write);

    // Register the PANDA_CB_INSN_EXEC callback
    pcb_insn_exec.insn_exec = on_insn_exec;
    panda_register_callback(self, PANDA_CB_INSN_EXEC, pcb_insn_exec);
    panda_disable_callback(self, PANDA_CB_INSN_EXEC, pcb_insn_exec);

    return true;
}

void uninit_plugin(void *self) {
    // Unregister the PANDA_CB_VIRT_MEM_BEFORE_WRITE callback
    panda_unregister_callback(self, PANDA_CB_VIRT_MEM_BEFORE_WRITE);

    // Unregister the PANDA_CB_PHYS_MEM_BEFORE_WRITE callback
    panda_unregister_callback(self, PANDA_CB_PHYS_MEM_BEFORE_WRITE);

    // Unregister the PANDA_CB_HD_WRITE callback
    panda_unregister_callback(self, PANDA_CB_HD_WRITE);

    // Unregister the PANDA_CB_INSN_EXEC callback
    panda_unregister_callback(self, PANDA_CB_INSN_EXEC);
}